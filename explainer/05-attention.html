<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Module 05: Attention Mechanism - NLP Course</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg: #0a0a0f;
            --surface: #12121a;
            --card: #1a1a2e;
            --border: #2a2a3e;
            --accent: #6c63ff;
            --accent2: #00d2ff;
            --accent3: #ff6b6b;
            --text: #e0e0e8;
            --muted: #8888a0;
        }

        body {
            background-color: var(--bg);
            color: var(--text);
            font-family: 'Inter', system-ui, sans-serif;
            line-height: 1.6;
            overflow-x: hidden;
        }

        /* ===== STICKY NAVBAR ===== */
        nav.sticky-nav {
            position: sticky;
            top: 0;
            z-index: 1000;
            background: linear-gradient(180deg, var(--surface) 0%, transparent 100%);
            padding: 1rem 2rem;
            backdrop-filter: blur(10px);
            border-bottom: 1px solid var(--border);
        }

        nav.sticky-nav a {
            color: var(--accent);
            text-decoration: none;
            font-size: 0.95rem;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            transition: color 0.3s;
        }

        nav.sticky-nav a:hover {
            color: var(--accent2);
        }

        /* ===== MAIN LAYOUT ===== */
        main {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }

        section {
            margin-bottom: 5rem;
        }

        section.fade-in {
            opacity: 0;
            transform: translateY(20px);
            animation: fadeIn 0.8s ease forwards;
        }

        @keyframes fadeIn {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* ===== HERO SECTION ===== */
        .hero {
            text-align: center;
            padding: 4rem 2rem;
            background: linear-gradient(135deg, var(--card) 0%, var(--surface) 100%);
            border-radius: 1rem;
            border: 1px solid var(--border);
            margin-bottom: 3rem;
            position: relative;
            overflow: hidden;
        }

        .hero h1 {
            font-size: 3.5rem;
            margin-bottom: 0.5rem;
            background: linear-gradient(135deg, var(--accent2), var(--accent));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .hero .subtitle {
            font-size: 1.3rem;
            color: var(--accent2);
            margin-bottom: 2rem;
        }

        .hero .duration {
            color: var(--muted);
            font-size: 0.95rem;
        }

        .hero svg {
            margin-top: 2rem;
            width: 100%;
            max-width: 500px;
            height: 200px;
        }

        /* ===== SECTION HEADERS ===== */
        h2 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            color: var(--accent2);
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        h2::before {
            content: '';
            display: inline-block;
            width: 4px;
            height: 2rem;
            background: linear-gradient(180deg, var(--accent), var(--accent2));
            border-radius: 2px;
        }

        h3 {
            font-size: 1.3rem;
            color: var(--accent);
            margin-bottom: 1rem;
            margin-top: 1.5rem;
        }

        p {
            color: var(--text);
            margin-bottom: 1rem;
            line-height: 1.8;
        }

        /* ===== CARDS ===== */
        .card {
            background-color: var(--card);
            border: 1px solid var(--border);
            border-radius: 0.75rem;
            padding: 2rem;
            margin-bottom: 1.5rem;
        }

        .card.interactive {
            cursor: pointer;
            transition: all 0.3s;
            border-color: var(--accent);
        }

        .card.interactive:hover {
            border-color: var(--accent2);
            box-shadow: 0 0 20px rgba(0, 210, 255, 0.2);
        }

        /* ===== SVG CONTAINER ===== */
        .svg-container {
            background-color: var(--surface);
            border: 1px solid var(--border);
            border-radius: 0.75rem;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 300px;
            overflow-x: auto;
        }

        svg {
            max-width: 100%;
            height: auto;
        }

        /* ===== GRID FOR CARDS ===== */
        .cards-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        .cards-grid .card {
            margin-bottom: 0;
        }

        /* ===== INTERACTIVE ELEMENTS ===== */
        .button-group {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            margin-bottom: 1.5rem;
        }

        button, select {
            background-color: var(--accent);
            color: var(--bg);
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            cursor: pointer;
            font-family: inherit;
            font-weight: 600;
            transition: all 0.3s;
            font-size: 0.95rem;
        }

        button:hover, select:hover {
            background-color: var(--accent2);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 210, 255, 0.3);
        }

        button.secondary {
            background-color: var(--surface);
            color: var(--accent);
            border: 1px solid var(--accent);
        }

        button.secondary:hover {
            background-color: var(--card);
            border-color: var(--accent2);
            color: var(--accent2);
        }

        select {
            background-color: var(--card);
            color: var(--text);
            border: 1px solid var(--border);
            padding: 0.75rem 1rem;
        }

        select:hover {
            border-color: var(--accent);
            background-color: var(--surface);
        }

        /* ===== SLIDERS ===== */
        .slider-container {
            margin: 2rem 0;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: var(--surface);
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--accent2);
            cursor: pointer;
            transition: all 0.2s;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 10px rgba(0, 210, 255, 0.5);
        }

        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--accent2);
            cursor: pointer;
            border: none;
            transition: all 0.2s;
        }

        input[type="range"]::-moz-range-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 10px rgba(0, 210, 255, 0.5);
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.5rem;
            font-size: 0.95rem;
            color: var(--muted);
        }

        /* ===== CODE BLOCK ===== */
        .code-block {
            background-color: var(--surface);
            border: 1px solid var(--border);
            border-radius: 0.75rem;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            overflow-x: auto;
        }

        pre {
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.5;
            color: var(--text);
        }

        .keyword { color: var(--accent); font-weight: 600; }
        .string { color: var(--accent2); }
        .comment { color: var(--muted); }
        .function { color: var(--accent3); }

        /* ===== NAV FOOTER ===== */
        .nav-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 2rem;
            background-color: var(--card);
            border: 1px solid var(--border);
            border-radius: 0.75rem;
            margin-top: 4rem;
        }

        .nav-footer a {
            color: var(--accent);
            text-decoration: none;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            transition: color 0.3s;
        }

        .nav-footer a:hover {
            color: var(--accent2);
        }

        /* ===== ATTENTION HEATMAP ===== */
        .heatmap-grid {
            display: inline-block;
            margin: 1rem 0;
        }

        .heatmap-cell {
            display: inline-block;
            width: 40px;
            height: 40px;
            margin: 2px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            border: 1px solid var(--border);
            position: relative;
        }

        .heatmap-cell:hover {
            transform: scale(1.1);
            box-shadow: 0 0 15px rgba(108, 99, 255, 0.5);
        }

        .heatmap-tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background-color: var(--surface);
            color: var(--text);
            padding: 0.5rem 0.75rem;
            border-radius: 0.4rem;
            font-size: 0.8rem;
            white-space: nowrap;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            border: 1px solid var(--border);
            z-index: 10;
        }

        .heatmap-cell:hover .heatmap-tooltip {
            opacity: 1;
        }

        /* ===== FORMULA BOXES ===== */
        .formula-box {
            background-color: var(--surface);
            border-left: 4px solid var(--accent);
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-radius: 0.5rem;
            font-family: 'Monaco', monospace;
            color: var(--text);
            overflow-x: auto;
        }

        /* ===== RESPONSIVE ===== */
        @media (max-width: 768px) {
            .hero h1 {
                font-size: 2.2rem;
            }

            h2 {
                font-size: 1.5rem;
            }

            main {
                padding: 1rem;
            }

            .cards-grid {
                grid-template-columns: 1fr;
            }

            .nav-footer {
                flex-direction: column;
                gap: 1rem;
                text-align: center;
            }

            .button-group {
                flex-direction: column;
            }

            button, select {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <nav class="sticky-nav">
        <a href="index.html">← Back to Course</a>
    </nav>

    <main>
        <!-- ===== HERO ===== -->
        <section class="hero fade-in">
            <h1>Module 05: Attention Mechanism</h1>
            <p class="subtitle">The idea that changed everything</p>
            <p class="duration">⏱️ ~25 minutes</p>
            <svg viewBox="0 0 800 200" xmlns="http://www.w3.org/2000/svg" id="heroAnimation">
                <!-- Source words -->
                <g id="sourceWords">
                    <circle cx="100" cy="50" r="25" fill="#6c63ff" opacity="0.8"/>
                    <text x="100" y="55" text-anchor="middle" fill="white" font-size="12" font-weight="bold">Le</text>

                    <circle cx="200" cy="50" r="25" fill="#6c63ff" opacity="0.8"/>
                    <text x="200" y="55" text-anchor="middle" fill="white" font-size="12" font-weight="bold">chat</text>

                    <circle cx="300" cy="50" r="25" fill="#6c63ff" opacity="0.8"/>
                    <text x="300" y="55" text-anchor="middle" fill="white" font-size="12" font-weight="bold">noir</text>

                    <circle cx="400" cy="50" r="25" fill="#6c63ff" opacity="0.8"/>
                    <text x="400" y="55" text-anchor="middle" fill="white" font-size="12" font-weight="bold">mange</text>
                </g>

                <!-- Target words -->
                <g id="targetWords">
                    <circle cx="100" cy="150" r="25" fill="#00d2ff" opacity="0.8"/>
                    <text x="100" y="155" text-anchor="middle" fill="white" font-size="12" font-weight="bold">The</text>

                    <circle cx="200" cy="150" r="25" fill="#00d2ff" opacity="0.8"/>
                    <text x="200" y="155" text-anchor="middle" fill="white" font-size="12" font-weight="bold">black</text>

                    <circle cx="300" cy="150" r="25" fill="#00d2ff" opacity="0.8"/>
                    <text x="300" y="155" text-anchor="middle" fill="white" font-size="12" font-weight="bold">cat</text>

                    <circle cx="400" cy="150" r="25" fill="#00d2ff" opacity="0.8"/>
                    <text x="400" y="155" text-anchor="middle" fill="white" font-size="12" font-weight="bold">eats</text>
                </g>

                <!-- Animated attention lines -->
                <g id="attentionLines" stroke-width="2" opacity="0.4"></g>
            </svg>
        </section>

        <!-- ===== THE BOTTLENECK RECAP ===== -->
        <section class="fade-in">
            <h2>The Bottleneck Problem</h2>
            <p>In the sequence-to-sequence model (Module 4), the encoder compresses an entire input sequence into a single vector. This vector must carry ALL the information the decoder needs. What if it can't?</p>

            <div class="svg-container">
                <svg viewBox="0 0 700 250" xmlns="http://www.w3.org/2000/svg" style="max-width: 100%;">
                    <!-- Encoder -->
                    <g id="encoder">
                        <text x="80" y="30" font-size="14" fill="#e0e0e8" font-weight="bold">ENCODER</text>
                        <circle cx="50" cy="80" r="20" fill="#6c63ff" opacity="0.7"/>
                        <circle cx="80" cy="80" r="20" fill="#6c63ff" opacity="0.8"/>
                        <circle cx="110" cy="80" r="20" fill="#6c63ff" opacity="0.8"/>
                        <circle cx="140" cy="80" r="20" fill="#6c63ff" opacity="0.7"/>
                        <text x="50" y="85" text-anchor="middle" font-size="11" fill="white" font-weight="bold">h₁</text>
                        <text x="80" y="85" text-anchor="middle" font-size="11" fill="white" font-weight="bold">h₂</text>
                        <text x="110" y="85" text-anchor="middle" font-size="11" fill="white" font-weight="bold">h₃</text>
                        <text x="140" y="85" text-anchor="middle" font-size="11" fill="white" font-weight="bold">h₄</text>
                    </g>

                    <!-- Bottleneck (context vector) -->
                    <g id="bottleneck">
                        <rect x="240" y="50" width="60" height="60" fill="#ff6b6b" opacity="0.3" stroke="#ff6b6b" stroke-width="2" stroke-dasharray="5,5"/>
                        <text x="270" y="85" text-anchor="middle" font-size="11" fill="#ff6b6b" font-weight="bold">c</text>
                        <text x="270" y="120" text-anchor="middle" font-size="12" fill="#ff6b6b" font-weight="bold">SQUEEZED!</text>
                    </g>

                    <!-- Arrows encoder to bottleneck -->
                    <path d="M 140 80 L 240 80" stroke="#ff6b6b" stroke-width="2" fill="none" marker-end="url(#arrowRed)"/>

                    <!-- Decoder -->
                    <g id="decoder">
                        <text x="420" y="30" font-size="14" fill="#e0e0e8" font-weight="bold">DECODER</text>
                        <circle cx="390" cy="80" r="20" fill="#00d2ff" opacity="0.7"/>
                        <circle cx="420" cy="80" r="20" fill="#00d2ff" opacity="0.8"/>
                        <circle cx="450" cy="80" r="20" fill="#00d2ff" opacity="0.8"/>
                        <circle cx="480" cy="80" r="20" fill="#00d2ff" opacity="0.7"/>
                        <text x="390" y="85" text-anchor="middle" font-size="11" fill="white" font-weight="bold">s₁</text>
                        <text x="420" y="85" text-anchor="middle" font-size="11" fill="white" font-weight="bold">s₂</text>
                        <text x="450" y="85" text-anchor="middle" font-size="11" fill="white" font-weight="bold">s₃</text>
                        <text x="480" y="85" text-anchor="middle" font-size="11" fill="white" font-weight="bold">s₄</text>
                    </g>

                    <!-- Arrows bottleneck to decoder -->
                    <path d="M 300 80 L 390 80" stroke="#ff6b6b" stroke-width="2" fill="none" marker-end="url(#arrowRed)"/>

                    <!-- Problem annotation -->
                    <text x="270" y="180" text-anchor="middle" font-size="13" fill="#ff6b6b" font-weight="bold">Problem: Information Loss</text>
                    <text x="270" y="200" text-anchor="middle" font-size="11" fill="#8888a0">One vector for entire sentence?</text>
                    <text x="270" y="220" text-anchor="middle" font-size="11" fill="#8888a0">Loses alignment with input words.</text>

                    <!-- Arrow markers -->
                    <defs>
                        <marker id="arrowRed" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto" markerUnits="strokeWidth">
                            <path d="M0,0 L0,6 L9,3 z" fill="#ff6b6b" />
                        </marker>
                    </defs>
                </svg>
            </div>

            <p><strong>The Question:</strong> What if instead of using a single compressed vector, the decoder could look back at ALL the encoder hidden states for each decoding step?</p>
        </section>

        <!-- ===== ATTENTION INTUITION ===== -->
        <section class="fade-in">
            <h2>Attention Intuition: The Translator Analogy</h2>
            <p>Imagine you're a human translator. You read a French sentence and write English word by word. When you write "cat", you glance back at the French word "chat". When you write "eats", you look at "mange". <strong>Different output words attend to different input words.</strong></p>

            <div class="svg-container">
                <svg viewBox="0 0 800 350" xmlns="http://www.w3.org/2000/svg" style="max-width: 100%;">
                    <!-- Source sentence -->
                    <text x="50" y="30" font-size="13" fill="#6c63ff" font-weight="bold">French (Input):</text>
                    <g id="frenchWords">
                        <circle cx="80" cy="80" r="30" fill="#6c63ff" opacity="0.6"/>
                        <text x="80" y="85" text-anchor="middle" fill="white" font-size="12" font-weight="bold">Le</text>

                        <circle cx="180" cy="80" r="30" fill="#6c63ff" opacity="0.6"/>
                        <text x="180" y="85" text-anchor="middle" fill="white" font-size="12" font-weight="bold">chat</text>

                        <circle cx="280" cy="80" r="30" fill="#6c63ff" opacity="0.6"/>
                        <text x="280" y="85" text-anchor="middle" fill="white" font-size="12" font-weight="bold">noir</text>

                        <circle cx="380" cy="80" r="30" fill="#6c63ff" opacity="0.6"/>
                        <text x="380" y="85" text-anchor="middle" fill="white" font-size="12" font-weight="bold">mange</text>
                    </g>

                    <!-- Translation table -->
                    <text x="50" y="180" font-size="13" fill="#00d2ff" font-weight="bold">English (Output):</text>

                    <!-- "The" -->
                    <g id="word-the">
                        <circle cx="80" cy="230" r="30" fill="#00d2ff" opacity="0.6"/>
                        <text x="80" y="235" text-anchor="middle" fill="white" font-size="12" font-weight="bold">The</text>
                        <path d="M 80 260 L 80 280" stroke="#6c63ff" stroke-width="2" opacity="0.3"/>
                        <text x="120" y="285" font-size="10" fill="#8888a0">← looks at "Le"</text>
                    </g>

                    <!-- "black" -->
                    <g id="word-black">
                        <circle cx="180" cy="230" r="30" fill="#00d2ff" opacity="0.6"/>
                        <text x="180" y="235" text-anchor="middle" fill="white" font-size="12" font-weight="bold">black</text>
                        <path d="M 180 260 L 280 120" stroke="#00d2ff" stroke-width="3" opacity="0.7" stroke-dasharray="3,3"/>
                        <text x="250" y="190" font-size="10" fill="#00d2ff" font-weight="bold">← ATTENDS TO "noir"</text>
                    </g>

                    <!-- "cat" - MAIN ATTENTION -->
                    <g id="word-cat">
                        <circle cx="280" cy="230" r="30" fill="#ff6b6b" opacity="0.8"/>
                        <text x="280" y="235" text-anchor="middle" fill="white" font-size="12" font-weight="bold">cat</text>
                        <path d="M 280 260 L 180 120" stroke="#ff6b6b" stroke-width="4" opacity="0.9"/>
                        <text x="210" y="185" font-size="11" fill="#ff6b6b" font-weight="bold">← ATTENDS TO "chat"</text>
                    </g>

                    <!-- "eats" -->
                    <g id="word-eats">
                        <circle cx="380" cy="230" r="30" fill="#00d2ff" opacity="0.6"/>
                        <text x="380" y="235" text-anchor="middle" fill="white" font-size="11" font-weight="bold">eats</text>
                        <path d="M 380 260 L 380 120" stroke="#6c63ff" stroke-width="2" opacity="0.5"/>
                        <text x="420" y="285" font-size="10" fill="#8888a0">← looks at "mange"</text>
                    </g>

                    <!-- Explanation -->
                    <text x="50" y="330" font-size="12" fill="#e0e0e8"><tspan font-weight="bold">Key insight:</tspan> The output "cat" has STRONG attention to "chat"</text>
                </svg>
            </div>

            <p style="margin-top: 2rem;">This is the core intuition of attention mechanisms: <strong>each decoder step learns which encoder states are most relevant.</strong> No more information loss through a bottleneck!</p>
        </section>

        <!-- ===== STEP-BY-STEP COMPUTATION ===== -->
        <section class="fade-in">
            <h2>Step-by-Step Attention Computation</h2>
            <p>Let's walk through exactly how attention is computed. Click on each target word to see the weights change!</p>

            <div class="button-group">
                <button onclick="selectWord('the')">The</button>
                <button onclick="selectWord('black')">black</button>
                <button onclick="selectWord('cat')" style="background-color: var(--accent3);">cat</button>
                <button onclick="selectWord('eats')">eats</button>
            </div>

            <!-- Step visualization -->
            <div class="card">
                <h3>Step 1: Encoder Hidden States</h3>
                <p>The encoder has processed the entire input. Each word has a hidden state:</p>
                <div style="display: flex; justify-content: space-around; margin-top: 1rem; flex-wrap: wrap;">
                    <div style="text-align: center; margin: 0.5rem;">
                        <div style="width: 50px; height: 50px; background: linear-gradient(135deg, #6c63ff, #00d2ff); border-radius: 4px; margin: 0 auto 0.5rem;"></div>
                        <div>h₁ = "Le"</div>
                    </div>
                    <div style="text-align: center; margin: 0.5rem;">
                        <div style="width: 50px; height: 50px; background: linear-gradient(135deg, #6c63ff, #00d2ff); border-radius: 4px; margin: 0 auto 0.5rem;"></div>
                        <div>h₂ = "chat"</div>
                    </div>
                    <div style="text-align: center; margin: 0.5rem;">
                        <div style="width: 50px; height: 50px; background: linear-gradient(135deg, #6c63ff, #00d2ff); border-radius: 4px; margin: 0 auto 0.5rem;"></div>
                        <div>h₃ = "noir"</div>
                    </div>
                    <div style="text-align: center; margin: 0.5rem;">
                        <div style="width: 50px; height: 50px; background: linear-gradient(135deg, #6c63ff, #00d2ff); border-radius: 4px; margin: 0 auto 0.5rem;"></div>
                        <div>h₄ = "mange"</div>
                    </div>
                </div>
            </div>

            <div class="card">
                <h3>Step 2: Compute Alignment Scores</h3>
                <p>For the current decoder state <strong>s</strong>, compute a score with each encoder state:</p>
                <div class="formula-box">score(s, hᵢ) = s · hᵢ  (dot product)</div>
                <p>For decoding word "cat", the scores might be:</p>
                <div id="scoresVisualization" style="margin-top: 1rem;">
                    <div style="margin: 0.5rem 0;">
                        <div style="display: flex; align-items: center; gap: 1rem;">
                            <span style="width: 60px;">Le:</span>
                            <div style="flex: 1; background: var(--surface); border-radius: 4px; overflow: hidden;">
                                <div id="scoreBar1" style="width: 15%; height: 30px; background: linear-gradient(90deg, var(--accent), var(--accent2)); transition: width 0.3s;"></div>
                            </div>
                            <span id="scoreValue1">0.3</span>
                        </div>
                    </div>
                    <div style="margin: 0.5rem 0;">
                        <div style="display: flex; align-items: center; gap: 1rem;">
                            <span style="width: 60px;">chat:</span>
                            <div style="flex: 1; background: var(--surface); border-radius: 4px; overflow: hidden;">
                                <div id="scoreBar2" style="width: 80%; height: 30px; background: linear-gradient(90deg, var(--accent), var(--accent2)); transition: width 0.3s;"></div>
                            </div>
                            <span id="scoreValue2">1.6</span>
                        </div>
                    </div>
                    <div style="margin: 0.5rem 0;">
                        <div style="display: flex; align-items: center; gap: 1rem;">
                            <span style="width: 60px;">noir:</span>
                            <div style="flex: 1; background: var(--surface); border-radius: 4px; overflow: hidden;">
                                <div id="scoreBar3" style="width: 25%; height: 30px; background: linear-gradient(90deg, var(--accent), var(--accent2)); transition: width 0.3s;"></div>
                            </div>
                            <span id="scoreValue3">0.5</span>
                        </div>
                    </div>
                    <div style="margin: 0.5rem 0;">
                        <div style="display: flex; align-items: center; gap: 1rem;">
                            <span style="width: 60px;">mange:</span>
                            <div style="flex: 1; background: var(--surface); border-radius: 4px; overflow: hidden;">
                                <div id="scoreBar4" style="width: 10%; height: 30px; background: linear-gradient(90deg, var(--accent), var(--accent2)); transition: width 0.3s;"></div>
                            </div>
                            <span id="scoreValue4">0.2</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="card">
                <h3>Step 3: Apply Softmax (Normalize to Probabilities)</h3>
                <p>Softmax converts raw scores to probabilities that sum to 1. This gives us attention weights:</p>
                <div id="softmaxVisualization" style="margin-top: 1rem;">
                    <div style="margin: 0.5rem 0;">
                        <div style="display: flex; align-items: center; gap: 1rem;">
                            <span style="width: 60px;">α₁:</span>
                            <div style="flex: 1; background: var(--surface); border-radius: 4px; overflow: hidden;">
                                <div id="alphaBar1" style="width: 8%; height: 30px; background: #ff6b6b; transition: width 0.3s;"></div>
                            </div>
                            <span id="alphaValue1" style="min-width: 70px;">0.08</span>
                        </div>
                    </div>
                    <div style="margin: 0.5rem 0;">
                        <div style="display: flex; align-items: center; gap: 1rem;">
                            <span style="width: 60px;">α₂:</span>
                            <div style="flex: 1; background: var(--surface); border-radius: 4px; overflow: hidden;">
                                <div id="alphaBar2" style="width: 70%; height: 30px; background: #ff6b6b; transition: width 0.3s;"></div>
                            </div>
                            <span id="alphaValue2" style="min-width: 70px;">0.70</span>
                        </div>
                    </div>
                    <div style="margin: 0.5rem 0;">
                        <div style="display: flex; align-items: center; gap: 1rem;">
                            <span style="width: 60px;">α₃:</span>
                            <div style="flex: 1; background: var(--surface); border-radius: 4px; overflow: hidden;">
                                <div id="alphaBar3" style="width: 15%; height: 30px; background: #ff6b6b; transition: width 0.3s;"></div>
                            </div>
                            <span id="alphaValue3" style="min-width: 70px;">0.15</span>
                        </div>
                    </div>
                    <div style="margin: 0.5rem 0;">
                        <div style="display: flex; align-items: center; gap: 1rem;">
                            <span style="width: 60px;">α₄:</span>
                            <div style="flex: 1; background: var(--surface); border-radius: 4px; overflow: hidden;">
                                <div id="alphaBar4" style="width: 7%; height: 30px; background: #ff6b6b; transition: width 0.3s;"></div>
                            </div>
                            <span id="alphaValue4" style="min-width: 70px;">0.07</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="card">
                <h3>Step 4: Weighted Sum (Context Vector)</h3>
                <p>Multiply each encoder state by its attention weight and sum:</p>
                <div class="formula-box">c = Σ αᵢ × hᵢ = 0.08×h₁ + <span style="background: var(--accent3); padding: 0 4px; color: var(--bg);">0.70×h₂</span> + 0.15×h₃ + 0.07×h₄</div>
                <p style="margin-top: 1rem; color: var(--accent3);"><strong>The context vector is now heavily weighted towards "chat"!</strong> This is fed into the decoder for predicting the next word.</p>
            </div>

            <div class="card interactive" onclick="toggleHeatmapSection()">
                <h3>Interactive Heatmap</h3>
                <p>The visualization below shows all attention weights for the complete translation. Hover over cells to see exact values. <strong>Click to expand!</strong></p>
            </div>
        </section>

        <!-- ===== ATTENTION HEATMAP ===== -->
        <section class="fade-in" id="heatmapSection" style="display: none;">
            <h2>Attention Heatmap Visualization</h2>

            <p>This heatmap shows attention weights for every (source word, target word) pair. Darker colors = higher attention weights.</p>

            <div class="button-group">
                <select onchange="switchHeatmapExample(this.value)">
                    <option value="fr-en">French → English</option>
                    <option value="en-ancient">English → Ancient Language</option>
                </select>
            </div>

            <div class="svg-container">
                <svg viewBox="0 0 500 400" xmlns="http://www.w3.org/2000/svg" id="heatmapSvg">
                    <!-- Y-axis label (target words) -->
                    <text x="30" y="30" font-size="11" fill="#8888a0" font-weight="bold">Target</text>

                    <!-- Source words (x-axis) -->
                    <text x="80" y="55" font-size="11" text-anchor="middle" fill="#6c63ff">Le</text>
                    <text x="150" y="55" font-size="11" text-anchor="middle" fill="#6c63ff">chat</text>
                    <text x="220" y="55" font-size="11" text-anchor="middle" fill="#6c63ff">noir</text>
                    <text x="290" y="55" font-size="11" text-anchor="middle" fill="#6c63ff">mange</text>
                    <text x="350" y="55" font-size="11" text-anchor="middle" fill="#8888a0">↓</text>
                    <text x="350" y="75" font-size="10" fill="#8888a0">Source</text>

                    <!-- Heatmap cells -->
                    <g id="heatmapCells">
                        <!-- Row 1: "The" -->
                        <rect x="70" y="90" width="30" height="30" fill="#4a2a2a" class="heatmap-cell" data-value="0.55" data-target="The" data-source="Le">
                            <title>The ← Le: 0.55</title>
                        </rect>
                        <rect x="140" y="90" width="30" height="30" fill="#2a2a3a" class="heatmap-cell" data-value="0.15" data-target="The" data-source="chat">
                            <title>The ← chat: 0.15</title>
                        </rect>
                        <rect x="210" y="90" width="30" height="30" fill="#2a2a3a" class="heatmap-cell" data-value="0.20" data-target="The" data-source="noir">
                            <title>The ← noir: 0.20</title>
                        </rect>
                        <rect x="280" y="90" width="30" height="30" fill="#2a2a3a" class="heatmap-cell" data-value="0.10" data-target="The" data-source="mange">
                            <title>The ← mange: 0.10</title>
                        </rect>

                        <!-- Row 2: "black" -->
                        <rect x="70" y="130" width="30" height="30" fill="#2a2a3a" class="heatmap-cell" data-value="0.10" data-target="black" data-source="Le">
                            <title>black ← Le: 0.10</title>
                        </rect>
                        <rect x="140" y="130" width="30" height="30" fill="#2a2a3a" class="heatmap-cell" data-value="0.15" data-target="black" data-source="chat">
                            <title>black ← chat: 0.15</title>
                        </rect>
                        <rect x="210" y="130" width="30" height="30" fill="#5a3a2a" class="heatmap-cell" data-value="0.70" data-target="black" data-source="noir">
                            <title>black ← noir: 0.70</title>
                        </rect>
                        <rect x="280" y="130" width="30" height="30" fill="#2a2a3a" class="heatmap-cell" data-value="0.05" data-target="black" data-source="mange">
                            <title>black ← mange: 0.05</title>
                        </rect>

                        <!-- Row 3: "cat" -->
                        <rect x="70" y="170" width="30" height="30" fill="#2a2a3a" class="heatmap-cell" data-value="0.08" data-target="cat" data-source="Le">
                            <title>cat ← Le: 0.08</title>
                        </rect>
                        <rect x="140" y="170" width="30" height="30" fill="#7a4a2a" class="heatmap-cell" data-value="0.70" data-target="cat" data-source="chat">
                            <title>cat ← chat: 0.70</title>
                        </rect>
                        <rect x="210" y="170" width="30" height="30" fill="#3a2a3a" class="heatmap-cell" data-value="0.15" data-target="cat" data-source="noir">
                            <title>cat ← noir: 0.15</title>
                        </rect>
                        <rect x="280" y="170" width="30" height="30" fill="#2a2a3a" class="heatmap-cell" data-value="0.07" data-target="cat" data-source="mange">
                            <title>cat ← mange: 0.07</title>
                        </rect>

                        <!-- Row 4: "eats" -->
                        <rect x="70" y="210" width="30" height="30" fill="#2a2a3a" class="heatmap-cell" data-value="0.12" data-target="eats" data-source="Le">
                            <title>eats ← Le: 0.12</title>
                        </rect>
                        <rect x="140" y="210" width="30" height="30" fill="#2a2a3a" class="heatmap-cell" data-value="0.10" data-target="eats" data-source="chat">
                            <title>eats ← chat: 0.10</title>
                        </rect>
                        <rect x="210" y="210" width="30" height="30" fill="#3a2a3a" class="heatmap-cell" data-value="0.18" data-target="eats" data-source="noir">
                            <title>eats ← noir: 0.18</title>
                        </rect>
                        <rect x="280" y="210" width="30" height="30" fill="#6a3a2a" class="heatmap-cell" data-value="0.60" data-target="eats" data-source="mange">
                            <title>eats ← mange: 0.60</title>
                        </rect>
                    </g>

                    <!-- Target word labels (y-axis) -->
                    <text x="40" y="110" font-size="11" text-anchor="end" fill="#00d2ff">The</text>
                    <text x="40" y="150" font-size="11" text-anchor="end" fill="#00d2ff">black</text>
                    <text x="40" y="190" font-size="11" text-anchor="end" fill="#00d2ff">cat</text>
                    <text x="40" y="230" font-size="11" text-anchor="end" fill="#00d2ff">eats</text>

                    <!-- Color scale legend -->
                    <text x="70" y="270" font-size="11" fill="#8888a0">Scale:</text>
                    <rect x="70" y="280" width="10" height="10" fill="#2a2a3a"/>
                    <text x="85" y="288" font-size="10" fill="#8888a0">0.0</text>

                    <rect x="140" y="280" width="10" height="10" fill="#4a3a2a"/>
                    <text x="155" y="288" font-size="10" fill="#8888a0">0.5</text>

                    <rect x="210" y="280" width="10" height="10" fill="#6a4a2a"/>
                    <text x="225" y="288" font-size="10" fill="#8888a0">0.7+</text>

                    <!-- Explanation -->
                    <text x="70" y="330" font-size="12" fill="#e0e0e8"><tspan font-weight="bold">Observation:</tspan> Dark diagonal pattern!</text>
                    <text x="70" y="350" font-size="10" fill="#8888a0">Target words align closely with source words.</text>
                </svg>
            </div>

            <p style="margin-top: 2rem;">Notice the clear alignment: "The" → "Le", "cat" → "chat", "eats" → "mange". The attention mechanism learns which words correspond to each other!</p>
        </section>

        <!-- ===== TYPES OF ATTENTION ===== -->
        <section class="fade-in">
            <h2>Types of Attention Mechanisms</h2>
            <p>Different ways to compute attention scores. All effective, but with different properties.</p>

            <div class="cards-grid">
                <div class="card interactive" onclick="selectAttentionType('bahdanau')">
                    <h3>Bahdanau (Additive)</h3>
                    <p>Uses a learned weight matrix to combine decoder and encoder states.</p>
                    <div class="formula-box" style="margin-top: 1rem;">score = v ⊤ tanh(W[s; h])</div>
                    <p style="margin-top: 1rem; font-size: 0.9rem; color: var(--accent3);">✓ Classic, well-studied<br>✓ Works well with LSTMs</p>
                </div>

                <div class="card interactive" onclick="selectAttentionType('luong')">
                    <h3>Luong (Dot-Product)</h3>
                    <p>Simple dot product between decoder and encoder states.</p>
                    <div class="formula-box" style="margin-top: 1rem;">score = s ⊤ W h</div>
                    <p style="margin-top: 1rem; font-size: 0.9rem; color: var(--accent);">✓ Faster<br>✓ Simpler to implement</p>
                </div>

                <div class="card interactive" onclick="selectAttentionType('scaled')">
                    <h3>Scaled Dot-Product</h3>
                    <p>Dot product normalized by dimension. Used in Transformers!</p>
                    <div class="formula-box" style="margin-top: 1rem;">score = (s ⊤ h) / √dₖ</div>
                    <p style="margin-top: 1rem; font-size: 0.9rem; color: var(--accent2);">✓ Numerically stable<br>✓ Powers modern LLMs</p>
                </div>
            </div>

            <div class="card" style="margin-top: 2rem;">
                <h3>Comparison: How They Work</h3>
                <p style="margin-bottom: 1.5rem;">All three compute attention in similar ways, but the scoring function differs:</p>

                <div id="attentionComparison">
                    <div style="background: var(--surface); padding: 1rem; border-radius: 0.5rem; margin-bottom: 1rem;">
                        <p><strong>Step 1 - Compute Scores:</strong></p>
                        <p id="scoreFormulaDisplay" style="font-family: monospace; color: var(--accent2); margin-top: 0.5rem;">Bahdanau: score = v⊤ tanh(W[s; h])</p>
                    </div>

                    <div style="background: var(--surface); padding: 1rem; border-radius: 0.5rem; margin-bottom: 1rem;">
                        <p><strong>Step 2 - Softmax:</strong></p>
                        <p style="font-family: monospace; color: var(--accent2); margin-top: 0.5rem;">All three use: αᵢ = exp(scoreᵢ) / Σⱼ exp(scoreⱼ)</p>
                    </div>

                    <div style="background: var(--surface); padding: 1rem; border-radius: 0.5rem;">
                        <p><strong>Step 3 - Context:</strong></p>
                        <p style="font-family: monospace; color: var(--accent2); margin-top: 0.5rem;">All three use: c = Σᵢ αᵢ × hᵢ</p>
                    </div>
                </div>
            </div>
        </section>

        <!-- ===== WHY ATTENTION SOLVES THE BOTTLENECK ===== -->
        <section class="fade-in">
            <h2>Why Attention Solves the Bottleneck</h2>
            <p>The key insight: with attention, gradients can flow directly from any output word to any input word, bypassing the narrow bottleneck.</p>

            <div class="svg-container">
                <svg viewBox="0 0 800 300" xmlns="http://www.w3.org/2000/svg" style="max-width: 100%;">
                    <!-- LEFT: Without Attention -->
                    <text x="150" y="30" font-size="14" fill="#e0e0e8" font-weight="bold">WITHOUT Attention</text>

                    <!-- Encoder -->
                    <circle cx="100" cy="80" r="18" fill="#6c63ff" opacity="0.6"/>
                    <circle cx="150" cy="80" r="18" fill="#6c63ff" opacity="0.6"/>
                    <circle cx="200" cy="80" r="18" fill="#6c63ff" opacity="0.6"/>
                    <text x="100" y="85" text-anchor="middle" font-size="10" fill="white">h₁</text>
                    <text x="150" y="85" text-anchor="middle" font-size="10" fill="white">h₂</text>
                    <text x="200" y="85" text-anchor="middle" font-size="10" fill="white">h₃</text>

                    <!-- Bottleneck -->
                    <circle cx="150" cy="150" r="20" fill="#ff6b6b" opacity="0.4" stroke="#ff6b6b" stroke-width="2"/>
                    <text x="150" y="155" text-anchor="middle" font-size="9" fill="#ff6b6b" font-weight="bold">c</text>

                    <!-- All arrows go through bottleneck -->
                    <path d="M 100 98 Q 130 120 135 130" stroke="#ff6b6b" stroke-width="2" fill="none" marker-end="url(#arrowSmall)"/>
                    <path d="M 150 98 L 150 130" stroke="#ff6b6b" stroke-width="2" fill="none" marker-end="url(#arrowSmall)"/>
                    <path d="M 200 98 Q 170 120 165 130" stroke="#ff6b6b" stroke-width="2" fill="none" marker-end="url(#arrowSmall)"/>

                    <!-- Decoder output -->
                    <circle cx="150" cy="220" r="18" fill="#00d2ff" opacity="0.6"/>
                    <text x="150" y="225" text-anchor="middle" font-size="10" fill="white">y</text>

                    <!-- Arrow from bottleneck to output -->
                    <path d="M 150 170 L 150 202" stroke="#ff6b6b" stroke-width="2" fill="none" marker-end="url(#arrowSmall)"/>

                    <!-- Bottleneck annotation -->
                    <text x="150" y="260" text-anchor="middle" font-size="11" fill="#ff6b6b">Bottleneck!</text>
                    <text x="150" y="280" text-anchor="middle" font-size="10" fill="#8888a0">Gradient flow limited</text>

                    <!-- RIGHT: With Attention -->
                    <text x="650" y="30" font-size="14" fill="#e0e0e8" font-weight="bold">WITH Attention</text>

                    <!-- Encoder -->
                    <circle cx="600" cy="80" r="18" fill="#6c63ff" opacity="0.6"/>
                    <circle cx="650" cy="80" r="18" fill="#6c63ff" opacity="0.6"/>
                    <circle cx="700" cy="80" r="18" fill="#6c63ff" opacity="0.6"/>
                    <text x="600" y="85" text-anchor="middle" font-size="10" fill="white">h₁</text>
                    <text x="650" y="85" text-anchor="middle" font-size="10" fill="white">h₂</text>
                    <text x="700" y="85" text-anchor="middle" font-size="10" fill="white">h₃</text>

                    <!-- Direct attention connections -->
                    <path d="M 600 98 L 600 200" stroke="#00d2ff" stroke-width="3" opacity="0.8" marker-end="url(#arrowBlue)"/>
                    <path d="M 650 98 L 650 200" stroke="#00d2ff" stroke-width="3" opacity="0.8" marker-end="url(#arrowBlue)"/>
                    <path d="M 700 98 L 700 200" stroke="#00d2ff" stroke-width="3" opacity="0.8" marker-end="url(#arrowBlue)"/>

                    <!-- Decoder output -->
                    <circle cx="650" cy="220" r="18" fill="#00d2ff" opacity="0.6"/>
                    <text x="650" y="225" text-anchor="middle" font-size="10" fill="white">y</text>

                    <!-- No bottleneck annotation -->
                    <text x="650" y="260" text-anchor="middle" font-size="11" fill="#00d2ff">Direct Access!</text>
                    <text x="650" y="280" text-anchor="middle" font-size="10" fill="#8888a0">Gradient flows directly</text>

                    <!-- Arrow markers -->
                    <defs>
                        <marker id="arrowSmall" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto" markerUnits="strokeWidth">
                            <path d="M0,0 L0,6 L9,3 z" fill="#ff6b6b" />
                        </marker>
                        <marker id="arrowBlue" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto" markerUnits="strokeWidth">
                            <path d="M0,0 L0,6 L9,3 z" fill="#00d2ff" />
                        </marker>
                    </defs>
                </svg>
            </div>

            <!-- Performance with sentence length -->
            <div class="card" style="margin-top: 2rem;">
                <h3>Performance vs. Sentence Length</h3>
                <p>Adjust the slider to see how attention maintains quality while vanilla seq2seq degrades:</p>

                <div class="slider-container">
                    <div class="slider-label">
                        <span>Sentence Length:</span>
                        <span id="lengthValue">10</span>
                    </div>
                    <input type="range" min="5" max="50" value="10" oninput="updatePerformanceChart(this.value)">
                </div>

                <svg viewBox="0 0 500 250" xmlns="http://www.w3.org/2000/svg" style="margin-top: 1.5rem; max-width: 100%;">
                    <!-- Axes -->
                    <line x1="50" y1="180" x2="480" y2="180" stroke="#2a2a3e" stroke-width="1"/>
                    <line x1="50" y1="20" x2="50" y2="180" stroke="#2a2a3e" stroke-width="1"/>

                    <!-- Axis labels -->
                    <text x="250" y="210" text-anchor="middle" font-size="11" fill="#8888a0">Sentence Length</text>
                    <text x="20" y="100" text-anchor="middle" font-size="11" fill="#8888a0" transform="rotate(-90 20 100)">BLEU Score</text>

                    <!-- Grid lines -->
                    <line x1="50" y1="150" x2="480" y2="150" stroke="#2a2a3e" stroke-width="0.5" opacity="0.3"/>
                    <line x1="50" y1="120" x2="480" y2="120" stroke="#2a2a3e" stroke-width="0.5" opacity="0.3"/>
                    <line x1="50" y1="90" x2="480" y2="90" stroke="#2a2a3e" stroke-width="0.5" opacity="0.3"/>
                    <line x1="50" y1="60" x2="480" y2="60" stroke="#2a2a3e" stroke-width="0.5" opacity="0.3"/>

                    <!-- Axis ticks and labels -->
                    <text x="50" y="195" text-anchor="middle" font-size="10" fill="#8888a0">5</text>
                    <text x="200" y="195" text-anchor="middle" font-size="10" fill="#8888a0">20</text>
                    <text x="350" y="195" text-anchor="middle" font-size="10" fill="#8888a0">35</text>
                    <text x="480" y="195" text-anchor="middle" font-size="10" fill="#8888a0">50</text>

                    <!-- Without attention (declining line) -->
                    <polyline id="noAttentionLine" points="50,120 200,140 350,170 480,180"
                              stroke="#ff6b6b" stroke-width="2" fill="none" stroke-linecap="round"/>
                    <circle id="noAttentionPoint" cx="50" cy="120" r="4" fill="#ff6b6b" opacity="0.8"/>

                    <!-- With attention (flat line) -->
                    <polyline id="withAttentionLine" points="50,50 200,48 350,52 480,50"
                              stroke="#00d2ff" stroke-width="2" fill="none" stroke-linecap="round"/>
                    <circle id="withAttentionPoint" cx="50" cy="50" r="4" fill="#00d2ff" opacity="0.8"/>

                    <!-- Legend -->
                    <line x1="300" y1="210" x2="330" y2="210" stroke="#ff6b6b" stroke-width="2"/>
                    <text x="340" y="215" font-size="11" fill="#ff6b6b">Without Attention</text>

                    <line x1="300" y1="230" x2="330" y2="230" stroke="#00d2ff" stroke-width="2"/>
                    <text x="340" y="235" font-size="11" fill="#00d2ff">With Attention</text>
                </svg>

                <p style="margin-top: 1rem; color: var(--accent2);"><strong>Key finding:</strong> Attention maintains translation quality even for long sentences!</p>
            </div>
        </section>

        <!-- ===== PYTHON CODE ===== -->
        <section class="fade-in">
            <h2>Python Implementation</h2>
            <p>Here's how to implement attention mechanisms in PyTorch:</p>

            <h3>Scaled Dot-Product Attention</h3>
            <div class="code-block">
                <pre><span class="keyword">import</span> torch
<span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn
<span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F
<span class="keyword">import</span> math

<span class="keyword">def</span> <span class="function">scaled_dot_product_attention</span>(query, key, value, mask=<span class="keyword">None</span>):
    <span class="string">"""
    Args:
        query: (batch, seq_len, d_k)
        key: (batch, seq_len, d_k)
        value: (batch, seq_len, d_v)
    Returns:
        output: (batch, seq_len, d_v)
        attention_weights: (batch, seq_len, seq_len)
    """</span>
    <span class="comment"># Compute scores</span>
    scores = torch.matmul(query, key.transpose(-2, -1)) / math.sqrt(query.size(-1))

    <span class="comment"># Apply mask if provided</span>
    <span class="keyword">if</span> mask <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:
        scores = scores.masked_fill(mask == 0, -1e9)

    <span class="comment"># Apply softmax</span>
    attention_weights = F.softmax(scores, dim=-1)

    <span class="comment"># Apply to values</span>
    output = torch.matmul(attention_weights, value)

    <span class="keyword">return</span> output, attention_weights</pre>
            </div>

            <h3>Bahdanau Attention</h3>
            <div class="code-block">
                <pre><span class="keyword">class</span> <span class="function">BahdanauAttention</span>(nn.Module):
    <span class="keyword">def</span> <span class="function">__init__</span>(<span class="keyword">self</span>, hidden_dim):
        <span class="keyword">super</span>().__init__()
        <span class="keyword">self</span>.query_proj = nn.Linear(hidden_dim, hidden_dim)
        <span class="keyword">self</span>.key_proj = nn.Linear(hidden_dim, hidden_dim)
        <span class="keyword">self</span>.v = nn.Linear(hidden_dim, 1)

    <span class="keyword">def</span> <span class="function">forward</span>(<span class="keyword">self</span>, query, keys):
        <span class="comment"># query: (batch, hidden_dim)</span>
        <span class="comment"># keys: (batch, seq_len, hidden_dim)</span>

        query = <span class="keyword">self</span>.query_proj(query)  <span class="comment"># (batch, hidden_dim)</span>
        query = query.unsqueeze(1)  <span class="comment"># (batch, 1, hidden_dim)</span>

        keys = <span class="keyword">self</span>.key_proj(keys)  <span class="comment"># (batch, seq_len, hidden_dim)</span>

        <span class="comment"># Compute alignment scores</span>
        scores = torch.tanh(query + keys)  <span class="comment"># (batch, seq_len, hidden_dim)</span>
        scores = <span class="keyword">self</span>.v(scores).squeeze(-1)  <span class="comment"># (batch, seq_len)</span>

        <span class="comment"># Softmax</span>
        weights = F.softmax(scores, dim=-1)  <span class="comment"># (batch, seq_len)</span>

        <span class="keyword">return</span> weights</pre>
            </div>

            <h3>Attention-Augmented Decoder</h3>
            <div class="code-block">
                <pre><span class="keyword">class</span> <span class="function">AttentionDecoder</span>(nn.Module):
    <span class="keyword">def</span> <span class="function">__init__</span>(<span class="keyword">self</span>, vocab_size, embed_dim, hidden_dim):
        <span class="keyword">super</span>().__init__()
        <span class="keyword">self</span>.embedding = nn.Embedding(vocab_size, embed_dim)
        <span class="keyword">self</span>.lstm = nn.LSTMCell(embed_dim + hidden_dim, hidden_dim)
        <span class="keyword">self</span>.attention = <span class="function">BahdanauAttention</span>(hidden_dim)
        <span class="keyword">self</span>.output_proj = nn.Linear(hidden_dim, vocab_size)

    <span class="keyword">def</span> <span class="function">forward</span>(<span class="keyword">self</span>, target_token, encoder_states, h, c):
        <span class="keyword"># Embed target token</span>
        embed = <span class="keyword">self</span>.embedding(target_token)

        <span class="keyword"># Compute attention</span>
        attn_weights = <span class="keyword">self</span>.attention(h, encoder_states)
        context = torch.bmm(attn_weights.unsqueeze(1), encoder_states)
        context = context.squeeze(1)

        <span class="keyword"># Concatenate and feed to LSTM</span>
        lstm_input = torch.cat([embed, context], dim=-1)
        h_new, c_new = <span class="keyword">self</span>.lstm(lstm_input, (h, c))

        <span class="keyword"># Predict next token</span>
        logits = <span class="keyword">self</span>.output_proj(h_new)

        <span class="keyword">return</span> logits, h_new, c_new</pre>
            </div>
        </section>

        <!-- ===== NAV FOOTER ===== -->
        <section class="fade-in">
            <div class="nav-footer">
                <a href="04-rnns.html">← RNNs & Seq2Seq</a>
                <span style="color: var(--muted);">Module 05 / 06</span>
                <a href="06-transformer.html">Transformer Architecture →</a>
            </div>
        </section>
    </main>

    <script>
        // ===== SCROLL ANIMATIONS =====
        const observerOptions = {
            threshold: 0.1,
            rootMargin: '0px 0px -100px 0px'
        };

        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    entry.target.style.animationDelay = '0s';
                }
            });
        }, observerOptions);

        document.querySelectorAll('section.fade-in').forEach(section => {
            observer.observe(section);
        });

        // ===== HERO ANIMATION =====
        function animateHeroConnections() {
            const svg = document.getElementById('heroAnimation');
            if (!svg) return;

            const connections = [
                { source: '100,50', target: '100,150', delay: 0 },
                { source: '200,50', target: '280,150', delay: 0.2 },
                { source: '300,50', target: '200,150', delay: 0.4 },
                { source: '400,50', target: '380,150', delay: 0.6 }
            ];

            const linesGroup = svg.getElementById('attentionLines');
            connections.forEach((conn, idx) => {
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', conn.source.split(',')[0]);
                line.setAttribute('y1', conn.source.split(',')[1]);
                line.setAttribute('x2', conn.target.split(',')[0]);
                line.setAttribute('y2', conn.target.split(',')[1]);
                line.setAttribute('stroke', '#00d2ff');
                line.setAttribute('stroke-width', '2');
                line.setAttribute('opacity', '0');
                line.style.animation = `fadeInLine 0.6s ease-in-out ${conn.delay}s forwards`;
                linesGroup.appendChild(line);
            });
        }

        // Add animation style
        const style = document.createElement('style');
        style.textContent = `
            @keyframes fadeInLine {
                to {
                    opacity: 0.6;
                }
            }
        `;
        document.head.appendChild(style);

        animateHeroConnections();
        setInterval(animateHeroConnections, 3000);

        // ===== WORD SELECTION FOR ATTENTION COMPUTATION =====
        const attentionData = {
            'the': { scores: [0.3, 0.15, 0.2, 0.1], alphas: [0.55, 0.15, 0.20, 0.10] },
            'black': { scores: [0.1, 0.15, 1.4, 0.1], alphas: [0.10, 0.15, 0.70, 0.05] },
            'cat': { scores: [0.3, 1.6, 0.5, 0.2], alphas: [0.08, 0.70, 0.15, 0.07] },
            'eats': { scores: [0.2, 0.1, 0.3, 1.2], alphas: [0.12, 0.10, 0.18, 0.60] }
        };

        function selectWord(word) {
            const data = attentionData[word];
            if (!data) return;

            // Update score bars
            for (let i = 0; i < 4; i++) {
                const maxScore = Math.max(...data.scores);
                const width = (data.scores[i] / maxScore) * 100;
                document.getElementById(`scoreBar${i + 1}`).style.width = width + '%';
                document.getElementById(`scoreValue${i + 1}`).textContent = data.scores[i].toFixed(1);
            }

            // Update softmax bars
            for (let i = 0; i < 4; i++) {
                const width = data.alphas[i] * 100;
                document.getElementById(`alphaBar${i + 1}`).style.width = width + '%';
                document.getElementById(`alphaValue${i + 1}`).textContent = data.alphas[i].toFixed(2);
            }

            // Highlight selected word
            document.querySelectorAll('.button-group button').forEach((btn, idx) => {
                if (btn.textContent.toLowerCase().trim() === word) {
                    btn.style.backgroundColor = 'var(--accent3)';
                } else {
                    btn.style.backgroundColor = 'var(--accent)';
                }
            });
        }

        // Initialize with 'cat'
        selectWord('cat');

        // ===== HEATMAP SECTION TOGGLE =====
        function toggleHeatmapSection() {
            const section = document.getElementById('heatmapSection');
            section.style.display = section.style.display === 'none' ? 'block' : 'none';
            section.classList.add('fade-in');
        }

        function switchHeatmapExample(lang) {
            console.log('Switching to:', lang);
            // Could load different data here
        }

        // ===== ATTENTION TYPE SELECTION =====
        function selectAttentionType(type) {
            const formulas = {
                'bahdanau': 'score = v⊤ tanh(W[s; h])',
                'luong': 'score = s⊤ W h',
                'scaled': 'score = (s⊤ h) / √dₖ'
            };

            document.getElementById('scoreFormulaDisplay').textContent =
                'Score: ' + formulas[type];

            // Highlight selected card
            document.querySelectorAll('.cards-grid .card').forEach(card => {
                card.style.borderColor = 'var(--border)';
            });

            event.currentTarget.style.borderColor = 'var(--accent2)';
            event.currentTarget.style.boxShadow = '0 0 20px rgba(0, 210, 255, 0.2)';
        }

        // ===== PERFORMANCE CHART UPDATE =====
        function updatePerformanceChart(value) {
            document.getElementById('lengthValue').textContent = value;

            const lengthNorm = (value - 5) / 45;

            // Declining performance without attention
            const x = 50 + (430 * lengthNorm);
            const y = 120 + (60 * lengthNorm);

            document.getElementById('noAttentionPoint').setAttribute('cx', x);
            document.getElementById('noAttentionPoint').setAttribute('cy', y);

            // Stable performance with attention
            const attentionX = 50 + (430 * lengthNorm);
            const attentionY = 50 + (Math.sin(lengthNorm * Math.PI) * 5);

            document.getElementById('withAttentionPoint').setAttribute('cx', attentionX);
            document.getElementById('withAttentionPoint').setAttribute('cy', attentionY);
        }

        // ===== HEATMAP HOVER EFFECTS =====
        document.querySelectorAll('.heatmap-cell').forEach(cell => {
            cell.addEventListener('mouseenter', () => {
                const value = cell.getAttribute('data-value');
                const target = cell.getAttribute('data-target');
                const source = cell.getAttribute('data-source');

                console.log(`Attention: ${target} ← ${source} = ${value}`);
            });
        });

        // ===== SYNTAX HIGHLIGHTING SIMULATION =====
        document.querySelectorAll('.code-block pre').forEach(block => {
            // Already styled with spans in HTML
        });
    </script>
</body>
</html>
