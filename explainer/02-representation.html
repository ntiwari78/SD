<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Module 2: Text Representation - NLP Course</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg: #0a0a0f;
            --surface: #12121a;
            --card: #1a1a2e;
            --border: #2a2a3e;
            --accent: #6c63ff;
            --accent2: #00d2ff;
            --accent3: #ff6b6b;
            --text: #e0e0e8;
            --muted: #8888a0;
            --code-bg: #0d1117;
        }

        body {
            background: var(--bg);
            color: var(--text);
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
            line-height: 1.6;
            overflow-x: hidden;
        }

        /* Navigation Bar */
        nav {
            position: sticky;
            top: 0;
            background: rgba(10, 10, 15, 0.95);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid var(--border);
            padding: 1rem 2rem;
            z-index: 100;
            display: flex;
            align-items: center;
            gap: 2rem;
        }

        .nav-back {
            color: var(--accent2);
            text-decoration: none;
            font-weight: 500;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .nav-back:hover {
            color: var(--accent);
            transform: translateX(-4px);
        }

        .nav-title {
            font-weight: 600;
            font-size: 1.1rem;
            color: var(--text);
        }

        /* Container */
        .container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 3rem 2rem;
        }

        /* Typography */
        h1 {
            font-size: 3rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
            background: linear-gradient(135deg, var(--accent), var(--accent2));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        h2 {
            font-size: 2rem;
            font-weight: 700;
            margin: 3rem 0 1.5rem 0;
            color: var(--accent);
            border-bottom: 2px solid var(--border);
            padding-bottom: 0.5rem;
        }

        h3 {
            font-size: 1.3rem;
            font-weight: 600;
            margin: 2rem 0 1rem 0;
            color: var(--accent2);
        }

        p, li {
            font-size: 1rem;
            margin-bottom: 1rem;
            color: var(--text);
        }

        .subtitle {
            font-size: 1.2rem;
            color: var(--muted);
            margin-bottom: 3rem;
        }

        /* Sections */
        section {
            margin-bottom: 4rem;
            padding: 2rem;
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 12px;
            opacity: 0;
            animation: fadeIn 0.6s ease forwards;
        }

        section:nth-child(1) { animation-delay: 0.1s; }
        section:nth-child(2) { animation-delay: 0.2s; }
        section:nth-child(3) { animation-delay: 0.3s; }
        section:nth-child(4) { animation-delay: 0.4s; }
        section:nth-child(5) { animation-delay: 0.5s; }
        section:nth-child(6) { animation-delay: 0.6s; }
        section:nth-child(7) { animation-delay: 0.7s; }
        section:nth-child(8) { animation-delay: 0.8s; }
        section:nth-child(9) { animation-delay: 0.9s; }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Hero Section */
        .hero {
            background: linear-gradient(135deg, rgba(108, 99, 255, 0.1) 0%, rgba(0, 210, 255, 0.05) 100%) !important;
            text-align: center;
            padding: 4rem 2rem !important;
        }

        .duration {
            display: inline-block;
            background: var(--accent);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            margin-bottom: 1rem;
        }

        /* Interactive Elements */
        .interactive-box {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
        }

        .input-group {
            margin-bottom: 1rem;
        }

        label {
            display: block;
            font-weight: 600;
            color: var(--accent2);
            margin-bottom: 0.5rem;
            font-size: 0.95rem;
        }

        textarea, input[type="text"] {
            width: 100%;
            padding: 0.75rem;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text);
            font-family: 'Inter', system-ui, sans-serif;
            font-size: 0.95rem;
            transition: border-color 0.3s ease;
        }

        textarea:focus, input[type="text"]:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(108, 99, 255, 0.1);
        }

        button {
            background: linear-gradient(135deg, var(--accent), var(--accent2));
            color: white;
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.95rem;
            margin-top: 0.5rem;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(108, 99, 255, 0.3);
        }

        button:active {
            transform: translateY(0);
        }

        /* SVG Charts */
        svg {
            max-width: 100%;
            height: auto;
            margin: 1.5rem 0;
        }

        .chart-container {
            display: flex;
            justify-content: center;
            background: var(--surface);
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
        }

        /* Data Display */
        .matrix-container {
            overflow-x: auto;
            margin: 1.5rem 0;
            background: var(--surface);
            border-radius: 8px;
            padding: 1rem;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9rem;
        }

        th, td {
            padding: 0.75rem;
            text-align: center;
            border: 1px solid var(--border);
        }

        th {
            background: var(--card);
            color: var(--accent2);
            font-weight: 600;
        }

        td {
            color: var(--text);
        }

        .matrix-cell {
            background: var(--bg);
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .matrix-cell:hover {
            background: rgba(108, 99, 255, 0.2);
            color: var(--accent2);
        }

        .matrix-cell.highlighted {
            background: rgba(108, 99, 255, 0.4);
            color: var(--accent2);
            font-weight: 600;
        }

        /* Code Blocks */
        .code-block {
            background: var(--code-bg);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 1.5rem;
            overflow-x: auto;
            margin: 1.5rem 0;
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.6;
        }

        .code-label {
            color: var(--accent2);
            font-weight: 600;
            margin-bottom: 1rem;
            display: block;
            font-size: 0.85rem;
        }

        pre {
            margin: 0;
            color: var(--text);
        }

        /* Syntax Highlighting */
        .keyword { color: #ff79c6; }
        .string { color: #f1fa8c; }
        .function { color: #8be9fd; }
        .comment { color: #6272a4; }
        .number { color: #bd93f9; }
        .operator { color: #ff79c6; }

        /* Lists */
        ul, ol {
            margin-left: 2rem;
            margin-bottom: 1rem;
        }

        li {
            margin-bottom: 0.5rem;
        }

        /* Footer Nav */
        .nav-footer {
            display: flex;
            justify-content: space-between;
            margin-top: 4rem;
            padding-top: 2rem;
            border-top: 1px solid var(--border);
            gap: 1rem;
        }

        .nav-footer a {
            flex: 1;
            padding: 1rem;
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 8px;
            text-decoration: none;
            color: var(--accent2);
            font-weight: 600;
            transition: all 0.3s ease;
            text-align: center;
        }

        .nav-footer a:hover {
            background: var(--surface);
            border-color: var(--accent);
            color: var(--accent);
        }

        /* Sliders */
        .slider-container {
            margin: 2rem 0;
            padding: 1rem;
            background: var(--surface);
            border-radius: 8px;
        }

        .slider-row {
            margin-bottom: 1.5rem;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: var(--border);
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--accent);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            background: var(--accent2);
            box-shadow: 0 0 10px rgba(0, 210, 255, 0.5);
        }

        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--accent);
            cursor: pointer;
            border: none;
            transition: all 0.3s ease;
        }

        input[type="range"]::-moz-range-thumb:hover {
            background: var(--accent2);
            box-shadow: 0 0 10px rgba(0, 210, 255, 0.5);
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
        }

        /* Highlight */
        .highlight {
            color: var(--accent2);
            font-weight: 600;
        }

        .example-box {
            background: linear-gradient(135deg, rgba(255, 107, 107, 0.05) 0%, rgba(255, 107, 107, 0.02) 100%);
            border-left: 4px solid var(--accent3);
            padding: 1.5rem;
            border-radius: 8px;
            margin: 1.5rem 0;
        }

        .note {
            background: linear-gradient(135deg, rgba(0, 210, 255, 0.05) 0%, rgba(0, 210, 255, 0.02) 100%);
            border-left: 4px solid var(--accent2);
            padding: 1.5rem;
            border-radius: 8px;
            margin: 1.5rem 0;
        }

        .two-column {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
            margin: 1.5rem 0;
        }

        @media (max-width: 768px) {
            .two-column {
                grid-template-columns: 1fr;
            }

            h1 {
                font-size: 2rem;
            }

            h2 {
                font-size: 1.5rem;
            }

            .container {
                padding: 1.5rem 1rem;
            }

            nav {
                flex-direction: column;
                align-items: flex-start;
                padding: 1rem;
            }
        }
    </style>
</head>
<body>
    <nav>
        <a href="index.html" class="nav-back">‚Üê Back to Course</a>
        <span class="nav-title">Module 02: Text Representation</span>
    </nav>

    <div class="container">
        <!-- Hero Section -->
        <section class="hero">
            <span class="duration">25 min read</span>
            <h1>Text Representation</h1>
            <p class="subtitle">Converting Words into Numbers: Bag of Words & TF-IDF</p>
            <p>Computers understand numbers, not words. Learn how to transform text into numerical representations that machine learning models can process.</p>
        </section>

        <!-- The Core Problem -->
        <section>
            <h2>The Core Problem: Computers Only Understand Numbers</h2>
            <p>Natural language is naturally linguistic‚Äîbeautiful and nuanced. But machine learning models are mathematicians. They need <span class="highlight">vectors</span>: sequences of numbers they can compute with.</p>

            <div class="chart-container">
                <svg viewBox="0 0 800 300" width="800" height="300" xmlns="http://www.w3.org/2000/svg">
                    <!-- Left side: Text -->
                    <rect x="20" y="50" width="200" height="200" fill="#1a1a2e" stroke="#2a2a3e" stroke-width="2" rx="8"/>
                    <text x="120" y="80" text-anchor="middle" fill="#e0e0e8" font-size="14" font-weight="600">Input Text</text>
                    <text x="120" y="130" text-anchor="middle" fill="#e0e0e8" font-size="13" font-family="monospace">
                        "the cat sat"
                    </text>
                    <text x="120" y="160" text-anchor="middle" fill="#e0e0e8" font-size="13" font-family="monospace">
                        "on the mat"
                    </text>

                    <!-- Arrow -->
                    <path d="M 240 150 L 320 150" stroke="#6c63ff" stroke-width="3" fill="none" marker-end="url(#arrowhead)"/>
                    <text x="280" y="140" text-anchor="middle" fill="#6c63ff" font-size="12" font-weight="600">Convert</text>

                    <!-- Right side: Numbers -->
                    <rect x="340" y="50" width="440" height="200" fill="#1a1a2e" stroke="#2a2a3e" stroke-width="2" rx="8"/>
                    <text x="560" y="80" text-anchor="middle" fill="#e0e0e8" font-size="14" font-weight="600">Numerical Vector</text>

                    <!-- Matrix representation -->
                    <g font-family="monospace" font-size="12" fill="#e0e0e8">
                        <text x="360" y="120">the  cat  sat  on  mat</text>
                        <text x="360" y="150">[2,   1,   1,  2,  1]</text>
                        <text x="360" y="180" fill="#00d2ff" font-weight="600">‚Üë Word frequencies</text>
                    </g>

                    <defs>
                        <marker id="arrowhead" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
                            <polygon points="0 0, 10 3, 0 6" fill="#6c63ff" />
                        </marker>
                    </defs>
                </svg>
            </div>

            <p>The goal is simple: <strong>map each unique word to a number</strong>, then represent each document as a collection of these numbers. Two approaches dominate this space: <span class="highlight">Bag of Words</span> and <span class="highlight">TF-IDF</span>.</p>
        </section>

        <!-- Bag of Words Interactive Demo -->
        <section>
            <h2>Bag of Words (BoW) Interactive Demo</h2>
            <p>Bag of Words is the simplest text representation. It counts how many times each word appears in a document, ignoring word order and grammar.</p>

            <div class="interactive-box">
                <div class="input-group">
                    <label for="bow-doc1">Document 1</label>
                    <textarea id="bow-doc1" rows="3" placeholder="Enter your first text here...">the cat sat on the mat</textarea>
                </div>
                <div class="input-group">
                    <label for="bow-doc2">Document 2</label>
                    <textarea id="bow-doc2" rows="3" placeholder="Enter your second text here...">the dog sat on the floor</textarea>
                </div>
                <button onclick="buildBoW()">Build Bag of Words</button>

                <div id="bow-output" style="margin-top: 2rem; display: none;">
                    <h3>Vocabulary Extracted</h3>
                    <p id="bow-vocab" style="font-family: monospace; background: var(--surface); padding: 1rem; border-radius: 6px;"></p>

                    <h3>Count Vectors</h3>
                    <div class="matrix-container">
                        <table id="bow-matrix">
                            <thead id="bow-header"></thead>
                            <tbody id="bow-body"></tbody>
                        </table>
                    </div>

                    <h3>Interactive Highlighting</h3>
                    <p style="color: var(--muted); font-size: 0.9rem;">Click a word below to highlight its column in the matrix:</p>
                    <div id="bow-words" style="display: flex; flex-wrap: wrap; gap: 0.5rem; margin-top: 1rem;"></div>
                </div>
            </div>

            <div class="note">
                <strong>Key Insight:</strong> Bag of Words ignores word <em>order</em> and treats the document as a collection of individual words. This simplicity is both a strength (easy to compute) and a weakness (loses context).
            </div>
        </section>

        <!-- TF-IDF Interactive -->
        <section>
            <h2>TF-IDF: Term Frequency-Inverse Document Frequency</h2>
            <p>TF-IDF improves on Bag of Words by recognizing that some words are more <em>important</em> than others. A word that appears in every document (like "the") is less informative than a word that appears in only one (like "specific").</p>

            <h3>The Math Behind TF-IDF</h3>
            <ul>
                <li><strong>TF (Term Frequency):</strong> How often a word appears in a document: <code style="color: var(--accent2);">TF = count(word) / total_words</code></li>
                <li><strong>IDF (Inverse Document Frequency):</strong> How rare a word is across documents: <code style="color: var(--accent2);">IDF = log(total_docs / docs_with_word)</code></li>
                <li><strong>TF-IDF:</strong> The product: <code style="color: var(--accent2);">TF-IDF = TF √ó IDF</code></li>
            </ul>

            <div class="interactive-box">
                <div class="input-group">
                    <label for="tfidf-doc1">Document 1</label>
                    <textarea id="tfidf-doc1" rows="2">machine learning is fascinating</textarea>
                </div>
                <div class="input-group">
                    <label for="tfidf-doc2">Document 2</label>
                    <textarea id="tfidf-doc2" rows="2">machine learning is powerful</textarea>
                </div>
                <div class="input-group">
                    <label for="tfidf-doc3">Document 3</label>
                    <textarea id="tfidf-doc3" rows="2">natural language processing rocks</textarea>
                </div>
                <button onclick="buildTFIDF()">Calculate TF-IDF</button>

                <div id="tfidf-output" style="margin-top: 2rem; display: none;">
                    <h3>TF Scores (Document 1)</h3>
                    <div class="chart-container">
                        <svg id="tf-chart" viewBox="0 0 500 250" width="500" height="250" xmlns="http://www.w3.org/2000/svg"></svg>
                    </div>

                    <h3>IDF Scores (All Documents)</h3>
                    <div class="chart-container">
                        <svg id="idf-chart" viewBox="0 0 500 250" width="500" height="250" xmlns="http://www.w3.org/2000/svg"></svg>
                    </div>

                    <h3>TF-IDF Matrix (with hover breakdown)</h3>
                    <div class="matrix-container">
                        <table id="tfidf-matrix">
                            <thead id="tfidf-header"></thead>
                            <tbody id="tfidf-body"></tbody>
                        </table>
                    </div>
                </div>
            </div>

            <div class="note">
                <strong>Why TF-IDF Works:</strong> Words like "machine" and "learning" get high scores because they appear frequently in some documents but not all. Words like "is" get low scores because they appear everywhere.
            </div>
        </section>

        <!-- Why They Work -->
        <section>
            <h2>Why They Work: Document Similarity</h2>
            <p>Once you have vectors, you can measure how similar two documents are using <span class="highlight">cosine similarity</span>‚Äîthe angle between their vectors in high-dimensional space.</p>

            <h3>Cosine Similarity Visualization</h3>
            <p style="color: var(--muted); font-size: 0.95rem;">Adjust the sliders to control two document vectors and watch the angle between them change:</p>

            <div class="slider-container">
                <div class="slider-row">
                    <div class="slider-label">
                        <span>Document 1</span>
                        <span id="vec1-value">45¬∞</span>
                    </div>
                    <input type="range" id="vec1-slider" min="0" max="360" value="45" oninput="updateCosineSimilarity()">
                </div>

                <div class="slider-row">
                    <div class="slider-label">
                        <span>Document 2</span>
                        <span id="vec2-value">120¬∞</span>
                    </div>
                    <input type="range" id="vec2-slider" min="0" max="360" value="120" oninput="updateCosineSimilarity()">
                </div>
            </div>

            <div class="chart-container">
                <svg id="cosine-chart" viewBox="0 0 400 400" width="400" height="400" xmlns="http://www.w3.org/2000/svg"></svg>
            </div>

            <div id="similarity-result" style="text-align: center; margin-top: 1.5rem;">
                <p style="color: var(--muted);">Cosine Similarity:</p>
                <p id="similarity-score" style="font-size: 1.8rem; font-weight: 700; color: var(--accent);">0.65</p>
            </div>

            <div class="example-box">
                <strong>Real-world example:</strong> Two movie reviews:
                <ul style="margin-top: 1rem;">
                    <li>"The film was amazing, brilliant cinematography, incredible acting"</li>
                    <li>"The movie was terrible, awful script, poor direction"</li>
                </ul>
                <p style="margin-top: 1rem;">Both documents share common words like "the", "film", "script". But the TF-IDF scores will differ on key words: "amazing" vs "terrible". The cosine similarity will be low, correctly indicating dissimilarity.</p>
            </div>
        </section>

        <!-- Limitations -->
        <section>
            <h2>Limitations: What Gets Lost</h2>
            <p>Despite their popularity, Bag of Words and TF-IDF have serious limitations that become clear with just a moment's thought.</p>

            <h3>1. Word Order Doesn't Matter</h3>
            <div class="two-column">
                <div>
                    <p><strong>Sentence A:</strong><br><code style="color: var(--accent2);">"dog bites man"</code></p>
                </div>
                <div>
                    <p><strong>Sentence B:</strong><br><code style="color: var(--accent2);">"man bites dog"</code></p>
                </div>
            </div>
            <p>These sentences have completely opposite meanings, but they have <strong>identical Bag of Words representations</strong>:</p>
            <div style="text-align: center; font-family: monospace; background: var(--surface); padding: 1rem; border-radius: 8px; margin: 1rem 0;">
                BoW: [1 dog, 1 bites, 1 man]
            </div>

            <h3>2. High-Dimensional Sparse Vectors</h3>
            <p>With a vocabulary of 10,000 words, each document becomes a 10,000-dimensional vector with mostly zeros. This is the <strong>curse of dimensionality</strong>: lots of dimensions, few non-zero values.</p>

            <div class="chart-container">
                <svg viewBox="0 0 600 250" width="600" height="250" xmlns="http://www.w3.org/2000/svg">
                    <!-- Title -->
                    <text x="300" y="30" text-anchor="middle" fill="#e0e0e8" font-size="14" font-weight="600">Sparsity Problem</text>

                    <!-- Vocabulary size scale -->
                    <g font-family="monospace" font-size="12" fill="#8888a0">
                        <text x="50" y="80">100 words</text>
                        <text x="50" y="130">1,000 words</text>
                        <text x="50" y="180">10,000 words</text>
                        <text x="50" y="230">100,000 words</text>
                    </g>

                    <!-- Bars showing sparsity -->
                    <rect x="200" y="65" width="80" height="25" fill="#6c63ff" opacity="0.8"/>
                    <text x="290" y="82" fill="#e0e0e8" font-size="12">20% filled</text>

                    <rect x="200" y="115" width="40" height="25" fill="#6c63ff" opacity="0.6"/>
                    <text x="290" y="132" fill="#e0e0e8" font-size="12">4% filled</text>

                    <rect x="200" y="165" width="20" height="25" fill="#6c63ff" opacity="0.4"/>
                    <text x="290" y="182" fill="#e0e0e8" font-size="12">0.4% filled</text>

                    <rect x="200" y="215" width="10" height="25" fill="#6c63ff" opacity="0.2"/>
                    <text x="290" y="232" fill="#e0e0e8" font-size="12">0.04% filled</text>
                </svg>
            </div>

            <div class="note">
                <strong>Why this matters:</strong> Sparse vectors make machine learning slower and less effective. Storage grows linearly with vocabulary size, and similarity calculations become expensive.
            </div>

            <h3>3. No Semantic Understanding</h3>
            <p>Consider these word pairs:</p>
            <ul>
                <li>"cat" and "feline" have different vectors, despite meaning the same thing</li>
                <li>"happy" and "sad" have very different vectors, despite being semantically related (opposite emotions)</li>
            </ul>
            <p>Bag of Words treats all words as completely independent‚Äîno notion of similarity in meaning.</p>
        </section>

        <!-- Python Code -->
        <section>
            <h2>Python Implementation</h2>
            <p>Scikit-learn makes implementing Bag of Words and TF-IDF trivial. Here's everything you need:</p>

            <div class="code-block">
                <span class="code-label">üíª Bag of Words with CountVectorizer</span>
                <pre><span class="keyword">from</span> <span class="function">sklearn.feature_extraction.text</span> <span class="keyword">import</span> CountVectorizer

<span class="comment"># Create documents</span>
documents = [
    <span class="string">"the cat sat on the mat"</span>,
    <span class="string">"the dog sat on the floor"</span>,
]

<span class="comment"># Initialize and fit the vectorizer</span>
bow = CountVectorizer()
bow_matrix = bow.fit_transform(documents)

<span class="comment"># Get the vocabulary</span>
print(bow.get_feature_names_out())
<span class="comment"># Output: ['cat' 'dog' 'floor' 'mat' 'on' 'sat' 'the']</span>

<span class="comment"># View the count matrix</span>
print(bow_matrix.toarray())
<span class="comment"># Output:</span>
<span class="comment"># [[1 0 0 1 1 1 2]  (doc 1: cat=1, dog=0, floor=0, mat=1, on=1, sat=1, the=2)</span>
<span class="comment">#  [0 1 1 0 1 1 1]] (doc 2: cat=0, dog=1, floor=1, mat=0, on=1, sat=1, the=1)</span></pre>
            </div>

            <div class="code-block">
                <span class="code-label">üíª TF-IDF with TfidfVectorizer</span>
                <pre><span class="keyword">from</span> <span class="function">sklearn.feature_extraction.text</span> <span class="keyword">import</span> TfidfVectorizer

<span class="comment"># Initialize TF-IDF vectorizer</span>
tfidf = TfidfVectorizer()
tfidf_matrix = tfidf.fit_transform(documents)

<span class="comment"># View the TF-IDF scores (0-1 normalized)</span>
print(tfidf_matrix.toarray())
<span class="comment"># Output: values between 0 and 1, weighted by importance</span>

<span class="comment"># Get IDF scores for each word</span>
<span class="keyword">for</span> word, idx <span class="keyword">in</span> tfidf.vocabulary_.items():
    print(f<span class="string">"{word}: IDF = {tfidf.idf_[idx]:.3f}"</span>)</pre>
            </div>

            <div class="code-block">
                <span class="code-label">üíª Simple Text Classification Pipeline</span>
                <pre><span class="keyword">from</span> <span class="function">sklearn.feature_extraction.text</span> <span class="keyword">import</span> TfidfVectorizer
<span class="keyword">from</span> <span class="function">sklearn.linear_model</span> <span class="keyword">import</span> LogisticRegression
<span class="keyword">from</span> <span class="function">sklearn.pipeline</span> <span class="keyword">import</span> Pipeline

<span class="comment"># Training data (movie reviews)</span>
reviews = [
    <span class="string">"this movie is amazing and brilliant"</span>,
    <span class="string">"i loved every minute of it"</span>,
    <span class="string">"terrible waste of time"</span>,
    <span class="string">"awful movie, bad acting"</span>,
]
labels = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]  <span class="comment"># 1=positive, 0=negative</span>

<span class="comment"># Create pipeline: vectorize ‚Üí classify</span>
pipeline = Pipeline([
    (<span class="string">'tfidf'</span>, TfidfVectorizer()),
    (<span class="string">'classifier'</span>, LogisticRegression()),
])

<span class="comment"># Train</span>
pipeline.fit(reviews, labels)

<span class="comment"># Predict on new reviews</span>
new_reviews = [
    <span class="string">"wonderful film, highly recommend"</span>,
    <span class="string">"complete disaster"</span>,
]
predictions = pipeline.predict(new_reviews)
print(predictions)  <span class="comment"># Output: [1, 0] (positive, negative)</span>

<span class="comment"># Get confidence scores</span>
probabilities = pipeline.predict_proba(new_reviews)
print(probabilities)  <span class="comment"># Probabilities for each class</span></pre>
            </div>

            <div class="note">
                <strong>Key Functions to Know:</strong>
                <ul style="margin-top: 1rem;">
                    <li><code style="color: var(--accent2);">CountVectorizer()</code> ‚Äì Bag of Words</li>
                    <li><code style="color: var(--accent2);">TfidfVectorizer()</code> ‚Äì TF-IDF</li>
                    <li><code style="color: var(--accent2);">fit_transform()</code> ‚Äì Learn vocabulary and transform documents</li>
                    <li><code style="color: var(--accent2);">.toarray()</code> ‚Äì Convert sparse matrix to dense for viewing</li>
                    <li><code style="color: var(--accent2);">Pipeline()</code> ‚Äì Chain vectorizer with classifier</li>
                </ul>
            </div>
        </section>

        <!-- Translation Connection -->
        <section>
            <h2>Connection: Ancient Language Analysis</h2>
            <p>How does this connect to our ancient language translation problem? Bag of Words and TF-IDF are <strong>baseline approaches</strong> for finding similar texts across languages and time periods.</p>

            <h3>Use Cases in Language Analysis:</h3>
            <ul>
                <li><strong>Text Similarity:</strong> Find which ancient texts are most similar to each other. A fragment of unknown origin might match 80% with a known manuscript using TF-IDF scores.</li>
                <li><strong>Keyword Extraction:</strong> Identify the most important words (using TF-IDF) in a text. These are likely to be domain-specific terms that help identify the text's subject.</li>
                <li><strong>Quick Baselines:</strong> Before building complex models, TF-IDF + logistic regression serves as a benchmark. "If we can't beat this simple approach, something is wrong with our complex model."</li>
                <li><strong>Multilingual Search:</strong> TF-IDF vectors can be compared across languages (with careful preprocessing) to find equivalent passages.</li>
            </ul>

            <div class="example-box">
                <strong>Example:</strong> Suppose you have Latin texts from 50 BC to 200 AD. You can:
                <ol style="margin-top: 1rem;">
                    <li>Vectorize each text using TF-IDF</li>
                    <li>Calculate cosine similarity between all pairs</li>
                    <li>Cluster texts by similarity to find related works</li>
                    <li>Use TF-IDF to identify characteristic vocabulary for different time periods</li>
                </ol>
            </div>

            <p style="margin-top: 1.5rem;">The main limitation: TF-IDF completely ignores grammar, semantics, and word order. For translation, we'll need more sophisticated approaches like word embeddings (next module!), but TF-IDF remains useful for initial exploration.</p>
        </section>

        <!-- Footer Navigation -->
        <section style="border: none; background: transparent; padding: 0;">
            <div class="nav-footer">
                <a href="01-preprocessing.html">‚Üê Module 01: Preprocessing</a>
                <a href="03-embeddings.html">Module 03: Word Embeddings ‚Üí</a>
            </div>
        </section>
    </div>

    <script>
        // Bag of Words Demo
        function buildBoW() {
            const doc1 = document.getElementById('bow-doc1').value.toLowerCase().trim();
            const doc2 = document.getElementById('bow-doc2').value.toLowerCase().trim();

            if (!doc1 || !doc2) {
                alert('Please enter text in both documents');
                return;
            }

            // Build vocabulary
            const words1 = doc1.split(/\s+/).filter(w => w.length > 0);
            const words2 = doc2.split(/\s+/).filter(w => w.length > 0);
            const vocab = [...new Set([...words1, ...words2])].sort();

            // Count vectors
            const count1 = vocab.map(word => words1.filter(w => w === word).length);
            const count2 = vocab.map(word => words2.filter(w => w === word).length);

            // Display vocabulary
            document.getElementById('bow-vocab').textContent = vocab.join(', ');

            // Build table
            const header = document.getElementById('bow-header');
            const body = document.getElementById('bow-body');
            header.innerHTML = '<tr><th>Document</th>' + vocab.map(w => `<th>${w}</th>`).join('') + '</tr>';

            body.innerHTML = `
                <tr>
                    <th>Doc 1</th>
                    ${count1.map((c, i) => `<td class="matrix-cell" data-word="${vocab[i]}" onclick="highlightBowColumn('${vocab[i]}')">${c}</td>`).join('')}
                </tr>
                <tr>
                    <th>Doc 2</th>
                    ${count2.map((c, i) => `<td class="matrix-cell" data-word="${vocab[i]}" onclick="highlightBowColumn('${vocab[i]}')">${c}</td>`).join('')}
                </tr>
            `;

            // Word buttons
            const wordsDiv = document.getElementById('bow-words');
            wordsDiv.innerHTML = vocab.map(w =>
                `<button style="padding: 0.5rem 1rem; font-size: 0.85rem;" onclick="highlightBowColumn('${w}')">${w}</button>`
            ).join('');

            document.getElementById('bow-output').style.display = 'block';
        }

        function highlightBowColumn(word) {
            // Clear all highlights
            document.querySelectorAll('.matrix-cell').forEach(cell => {
                cell.classList.remove('highlighted');
            });

            // Highlight selected word
            document.querySelectorAll(`[data-word="${word}"]`).forEach(cell => {
                cell.classList.add('highlighted');
            });
        }

        // TF-IDF Demo
        function buildTFIDF() {
            const doc1 = document.getElementById('tfidf-doc1').value.toLowerCase().trim();
            const doc2 = document.getElementById('tfidf-doc2').value.toLowerCase().trim();
            const doc3 = document.getElementById('tfidf-doc3').value.toLowerCase().trim();

            if (!doc1 || !doc2 || !doc3) {
                alert('Please enter text in all three documents');
                return;
            }

            const docs = [doc1, doc2, doc3];
            const words = docs.flatMap(d => d.split(/\s+/)).filter(w => w.length > 0);
            const vocab = [...new Set(words)].sort();

            // Calculate TF for doc1
            const words1 = doc1.split(/\s+/).filter(w => w.length > 0);
            const tf = {};
            const totalWords = words1.length;
            vocab.forEach(word => {
                const count = words1.filter(w => w === word).length;
                tf[word] = count / totalWords;
            });

            // Calculate IDF
            const idf = {};
            const totalDocs = docs.length;
            vocab.forEach(word => {
                const docsWithWord = docs.filter(d => d.includes(word)).length;
                idf[word] = Math.log(totalDocs / docsWithWord);
            });

            // Calculate TF-IDF for all docs
            const tfidfMatrix = docs.map((doc, docIdx) => {
                const docWords = doc.split(/\s+/).filter(w => w.length > 0);
                return vocab.map(word => {
                    const count = docWords.filter(w => w === word).length;
                    const tf_score = count / docWords.length;
                    return (tf_score * idf[word]).toFixed(3);
                });
            });

            // Draw TF Chart
            drawTFChart(vocab, tf);

            // Draw IDF Chart
            drawIDFChart(vocab, idf);

            // Build TF-IDF table
            const header = document.getElementById('tfidf-header');
            const body = document.getElementById('tfidf-body');

            header.innerHTML = '<tr><th>Document</th>' + vocab.map(w => `<th>${w}</th>`).join('') + '</tr>';

            body.innerHTML = tfidfMatrix.map((row, docIdx) => `
                <tr>
                    <th>Doc ${docIdx + 1}</th>
                    ${row.map((val, wordIdx) => {
                        const tf = (tfidfMatrix[docIdx][wordIdx] / idf[vocab[wordIdx]]).toFixed(3);
                        const idfVal = idf[vocab[wordIdx]].toFixed(3);
                        const intensity = Math.min(1, parseFloat(val) * 2);
                        const bgColor = `rgba(108, 99, 255, ${intensity * 0.6})`;
                        return `<td class="matrix-cell" style="background: ${bgColor};" title="TF=${tf} √ó IDF=${idfVal}">${val}</td>`;
                    }).join('')}
                </tr>
            `).join('');

            document.getElementById('tfidf-output').style.display = 'block';
        }

        function drawTFChart(vocab, tf) {
            const svg = document.getElementById('tf-chart');
            svg.innerHTML = '';

            const padding = 40;
            const width = 500 - 2 * padding;
            const height = 250 - 2 * padding;
            const maxVal = Math.max(...Object.values(tf));
            const barWidth = Math.min(30, width / vocab.length - 5);
            const spacing = width / vocab.length;

            // Axes
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');

            // X axis
            const xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            xAxis.setAttribute('x1', padding);
            xAxis.setAttribute('y1', padding + height);
            xAxis.setAttribute('x2', padding + width);
            xAxis.setAttribute('y2', padding + height);
            xAxis.setAttribute('stroke', '#2a2a3e');
            xAxis.setAttribute('stroke-width', '2');
            g.appendChild(xAxis);

            // Y axis
            const yAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            yAxis.setAttribute('x1', padding);
            yAxis.setAttribute('y1', padding);
            yAxis.setAttribute('x2', padding);
            yAxis.setAttribute('y2', padding + height);
            yAxis.setAttribute('stroke', '#2a2a3e');
            yAxis.setAttribute('stroke-width', '2');
            g.appendChild(yAxis);

            // Bars
            vocab.forEach((word, i) => {
                const x = padding + i * spacing + spacing / 2 - barWidth / 2;
                const y_val = tf[word] || 0;
                const barHeight = (y_val / maxVal) * height;
                const y = padding + height - barHeight;

                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('x', x);
                rect.setAttribute('y', y);
                rect.setAttribute('width', barWidth);
                rect.setAttribute('height', barHeight);
                rect.setAttribute('fill', '#6c63ff');
                rect.setAttribute('opacity', '0.8');
                rect.setAttribute('rx', '4');
                g.appendChild(rect);

                // Label
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', x + barWidth / 2);
                text.setAttribute('y', padding + height + 20);
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('fill', '#e0e0e8');
                text.setAttribute('font-size', '12');
                text.textContent = word;
                g.appendChild(text);

                // Value
                const val = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                val.setAttribute('x', x + barWidth / 2);
                val.setAttribute('y', y - 5);
                val.setAttribute('text-anchor', 'middle');
                val.setAttribute('fill', '#00d2ff');
                val.setAttribute('font-size', '11');
                val.setAttribute('font-weight', '600');
                val.textContent = (tf[word] || 0).toFixed(2);
                g.appendChild(val);
            });

            // Title
            const title = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            title.setAttribute('x', 250);
            title.setAttribute('y', 25);
            title.setAttribute('text-anchor', 'middle');
            title.setAttribute('fill', '#e0e0e8');
            title.setAttribute('font-size', '14');
            title.setAttribute('font-weight', '600');
            title.textContent = 'Term Frequency (Document 1)';
            g.appendChild(title);

            svg.appendChild(g);
        }

        function drawIDFChart(vocab, idf) {
            const svg = document.getElementById('idf-chart');
            svg.innerHTML = '';

            const padding = 40;
            const width = 500 - 2 * padding;
            const height = 250 - 2 * padding;
            const maxVal = Math.max(...Object.values(idf));
            const barWidth = Math.min(30, width / vocab.length - 5);
            const spacing = width / vocab.length;

            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');

            // Axes
            const xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            xAxis.setAttribute('x1', padding);
            xAxis.setAttribute('y1', padding + height);
            xAxis.setAttribute('x2', padding + width);
            xAxis.setAttribute('y2', padding + height);
            xAxis.setAttribute('stroke', '#2a2a3e');
            xAxis.setAttribute('stroke-width', '2');
            g.appendChild(xAxis);

            const yAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            yAxis.setAttribute('x1', padding);
            yAxis.setAttribute('y1', padding);
            yAxis.setAttribute('x2', padding);
            yAxis.setAttribute('y2', padding + height);
            yAxis.setAttribute('stroke', '#2a2a3e');
            yAxis.setAttribute('stroke-width', '2');
            g.appendChild(yAxis);

            // Bars
            vocab.forEach((word, i) => {
                const x = padding + i * spacing + spacing / 2 - barWidth / 2;
                const y_val = idf[word] || 0;
                const barHeight = (y_val / maxVal) * height;
                const y = padding + height - barHeight;

                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('x', x);
                rect.setAttribute('y', y);
                rect.setAttribute('width', barWidth);
                rect.setAttribute('height', barHeight);
                rect.setAttribute('fill', '#00d2ff');
                rect.setAttribute('opacity', '0.8');
                rect.setAttribute('rx', '4');
                g.appendChild(rect);

                // Label
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', x + barWidth / 2);
                text.setAttribute('y', padding + height + 20);
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('fill', '#e0e0e8');
                text.setAttribute('font-size', '12');
                text.textContent = word;
                g.appendChild(text);

                // Value
                const val = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                val.setAttribute('x', x + barWidth / 2);
                val.setAttribute('y', y - 5);
                val.setAttribute('text-anchor', 'middle');
                val.setAttribute('fill', '#6c63ff');
                val.setAttribute('font-size', '11');
                val.setAttribute('font-weight', '600');
                val.textContent = (idf[word] || 0).toFixed(2);
                g.appendChild(val);
            });

            // Title
            const title = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            title.setAttribute('x', 250);
            title.setAttribute('y', 25);
            title.setAttribute('text-anchor', 'middle');
            title.setAttribute('fill', '#e0e0e8');
            title.setAttribute('font-size', '14');
            title.setAttribute('font-weight', '600');
            title.textContent = 'Inverse Document Frequency';
            g.appendChild(title);

            svg.appendChild(g);
        }

        // Cosine Similarity Visualization
        function updateCosineSimilarity() {
            const angle1 = parseFloat(document.getElementById('vec1-slider').value);
            const angle2 = parseFloat(document.getElementById('vec2-slider').value);

            document.getElementById('vec1-value').textContent = angle1 + '¬∞';
            document.getElementById('vec2-value').textContent = angle2 + '¬∞';

            // Calculate cosine similarity
            const rad1 = angle1 * Math.PI / 180;
            const rad2 = angle2 * Math.PI / 180;
            const similarity = Math.cos((rad2 - rad1) * Math.PI / 180);

            document.getElementById('similarity-score').textContent = similarity.toFixed(2);

            // Update color based on similarity
            const color = similarity > 0.5 ? '#00d2ff' : similarity > 0 ? '#6c63ff' : '#ff6b6b';
            document.getElementById('similarity-score').style.color = color;

            // Draw diagram
            drawCosineDiagram(angle1, angle2, similarity);
        }

        function drawCosineDiagram(angle1, angle2, similarity) {
            const svg = document.getElementById('cosine-chart');
            svg.innerHTML = '';

            const centerX = 200;
            const centerY = 200;
            const radius = 120;

            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');

            // Circle
            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('cx', centerX);
            circle.setAttribute('cy', centerY);
            circle.setAttribute('r', radius);
            circle.setAttribute('fill', 'none');
            circle.setAttribute('stroke', '#2a2a3e');
            circle.setAttribute('stroke-width', '2');
            g.appendChild(circle);

            // Axes
            const axisX = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            axisX.setAttribute('x1', centerX - radius - 20);
            axisX.setAttribute('y1', centerY);
            axisX.setAttribute('x2', centerX + radius + 20);
            axisX.setAttribute('y2', centerY);
            axisX.setAttribute('stroke', '#2a2a3e');
            axisX.setAttribute('stroke-width', '1');
            axisX.setAttribute('opacity', '0.5');
            g.appendChild(axisX);

            const axisY = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            axisY.setAttribute('x1', centerX);
            axisY.setAttribute('y1', centerY - radius - 20);
            axisY.setAttribute('x2', centerX);
            axisY.setAttribute('y2', centerY + radius + 20);
            axisY.setAttribute('stroke', '#2a2a3e');
            axisY.setAttribute('stroke-width', '1');
            axisY.setAttribute('opacity', '0.5');
            g.appendChild(axisY);

            // Vector 1
            const rad1 = angle1 * Math.PI / 180;
            const x1 = centerX + radius * Math.cos(rad1);
            const y1 = centerY - radius * Math.sin(rad1);

            const line1 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line1.setAttribute('x1', centerX);
            line1.setAttribute('y1', centerY);
            line1.setAttribute('x2', x1);
            line1.setAttribute('y2', y1);
            line1.setAttribute('stroke', '#6c63ff');
            line1.setAttribute('stroke-width', '3');
            g.appendChild(line1);

            const circle1 = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle1.setAttribute('cx', x1);
            circle1.setAttribute('cy', y1);
            circle1.setAttribute('r', '5');
            circle1.setAttribute('fill', '#6c63ff');
            g.appendChild(circle1);

            // Vector 2
            const rad2 = angle2 * Math.PI / 180;
            const x2 = centerX + radius * Math.cos(rad2);
            const y2 = centerY - radius * Math.sin(rad2);

            const line2 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line2.setAttribute('x1', centerX);
            line2.setAttribute('y1', centerY);
            line2.setAttribute('x2', x2);
            line2.setAttribute('y2', y2);
            line2.setAttribute('stroke', '#00d2ff');
            line2.setAttribute('stroke-width', '3');
            g.appendChild(line2);

            const circle2 = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle2.setAttribute('cx', x2);
            circle2.setAttribute('cy', y2);
            circle2.setAttribute('r', '5');
            circle2.setAttribute('fill', '#00d2ff');
            g.appendChild(circle2);

            // Angle arc
            const angleDiff = Math.abs(angle2 - angle1);
            if (angleDiff > 0 && angleDiff < 180) {
                const arcRadius = 30;
                const arc = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                const startAngle = Math.min(rad1, rad2);
                const endAngle = Math.max(rad1, rad2);
                const x_start = centerX + arcRadius * Math.cos(startAngle);
                const y_start = centerY - arcRadius * Math.sin(startAngle);
                const x_end = centerX + arcRadius * Math.cos(endAngle);
                const y_end = centerY - arcRadius * Math.sin(endAngle);
                const largeArc = endAngle - startAngle > Math.PI ? 1 : 0;

                arc.setAttribute('d', `M ${x_start} ${y_start} A ${arcRadius} ${arcRadius} 0 ${largeArc} 1 ${x_end} ${y_end}`);
                arc.setAttribute('fill', 'none');
                arc.setAttribute('stroke', '#ff6b6b');
                arc.setAttribute('stroke-width', '2');
                arc.setAttribute('opacity', '0.6');
                g.appendChild(arc);
            }

            // Labels
            const label1 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            label1.setAttribute('x', x1 + 10);
            label1.setAttribute('y', y1 - 10);
            label1.setAttribute('fill', '#6c63ff');
            label1.setAttribute('font-size', '12');
            label1.setAttribute('font-weight', '600');
            label1.textContent = 'Doc 1';
            g.appendChild(label1);

            const label2 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            label2.setAttribute('x', x2 + 10);
            label2.setAttribute('y', y2 + 15);
            label2.setAttribute('fill', '#00d2ff');
            label2.setAttribute('font-size', '12');
            label2.setAttribute('font-weight', '600');
            label2.textContent = 'Doc 2';
            g.appendChild(label2);

            // Title
            const title = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            title.setAttribute('x', 200);
            title.setAttribute('y', 30);
            title.setAttribute('text-anchor', 'middle');
            title.setAttribute('fill', '#e0e0e8');
            title.setAttribute('font-size', '14');
            title.setAttribute('font-weight', '600');
            title.textContent = 'Cosine Similarity: Angle Between Vectors';
            g.appendChild(title);

            svg.appendChild(g);
        }

        // Initialize cosine similarity on load
        window.addEventListener('load', updateCosineSimilarity);
    </script>
</body>
</html>
